<html>
<head>
	<title>MTGI BehaviorTracking 1.x Reference: Justification</title>
	<style lang="text/css">
		
		body { margin: 1em; font-size: 12pt;}
		h1 { margin: 0; padding: 0;}
		h2 { font-size: 16pt; }
		h3 { font-size: 14pt; }
		h4 { font-size: 12pt; }
		p, table { margin-top: 1em; }
		td { vertical-align: top; padding: 1ex;}
		blockquote pre { background-color:#efefef; margin:0;padding:4ex;border:1px solid #999999; font-size: 8pt;}
		
	</style>
</head>
<body>
<h1>The case for production monitoring</h1>
<p>It is hard to predict how users will engage your application before it hits production.  You can invest much or little in your attempts to 
predict demand, but in either case your best educated guess cannot dictate  
the future.  If you can avoid performance problems on first release, monitoring  
is paramount to ensure that things stay under control  as users find new ways to  
torture your application.  If you do have problems on initial deployment,  
monitoring is paramount to finding and addressing a problem quickly. In any case,  
production monitoring is required.</p>

<h1>Existing Tools and Methods</h1> 
<p>There are many powerful tools available to monitor any modern Java application.  BehaviorTracking 
is designed to augment, not replace, the information that these tools provide.  A successful 
system will have a place for <i>every one of these tools</i>, almost without exception.&nbsp; What's most important is that you 
<i>actually measure</i> your system to understand where the problems lie.  The temptation 
to arbitrarily pick your least favorite part of the application and rewrite while your users suffer is a 
strong one and a good way to lose credibility.  The same goes for measuring arbitrary behaviors in a controlled test environment without a clear analogy to production user behavior. If your suspicion feels like certainty, it 
should be easy to find hard evidence to back it up, but don't forgo the exercise.</p>
<h2>System Resource Monitoring</h2>
<p>System resource monitoring tools are widely available and do not require you 
to make any special considerations in your application.  For example, most modern 
Windows systems have <a href="http://technet.microsoft.com/en-us/library/cc749115.aspx">Performance Monitor</a>, 
and most Unix systems will include some 
variant of <a href="http://pagesperso-orange.fr/sebastien.godard/documentation.html">sar</a>. In either case, you should be able to identify bottlenecks at the 
resource level (disk, memory, CPU, network).  If your system is simply being asked 
to do too much with the tools given, and you can address bottlenecks with better hardware, that's excellent.</p>
<p>If you are having application responsiveness problems and your resources are  
underutilized, you can't hope to get much more out of your resource monitors and must 
dig deeper.  If your system is overutilized with two users logging in and nothing more, you must dig 
deeper.  In short, you should anticipate a need for deeper visibility into your application 
than what resource monitoring tools alone can provide.</p>

<h2>JMX Monitoring</h2>
<p>Modern Java application servers provide a wealth of information to JMX clients 
(<a href="http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html">jconsole</a>, 
<a href="http://mc4j.org">MC4J</a>). 
If your application is overpowering the CPU, you can quickly identify which threads 
are eating your processor and what code they are executing while they are doing it. 
You can view heap memory use statistics, identify deadlocked threads, and usually  
(depending on application server) exercise some control over user sessions.</p>
<p>A significant limitation of JMX monitoring tools is that it is difficult to perform 
post-mortem analysis after your system has become unresponsive.  If your application 
is leaking memory, or pegs your processor, users of JMX clients are frequently 
as out-of-luck as users of your application. Some IT departments will consider (not entirely without merit) JMX  
access a security risk and will refuse to activate it.<br></p>

<h2>Access Logging</h2>
<p>All major web servers will provide some kind of configurable <a href="http://httpd.apache.org/docs/2.0/logs.html#accesslog">access logging</a>, 
usually in the style of the <a href="http://httpd.apache.org/">Apache web server</a>.  
An access log may include which URL was requested, 
when the request was made, which user made the request, a session ID associated with the request,  
how long the server spent processing the request, how large the response was, 
and whether the processing resulted in any errors.  The access log is the primary data 
source for many user analytics packages.  If you are writing a web application, access 
logging is a powerful tool for understanding how users are accessing your application 
and how their behavior changes over time.</p>
<p>Many applications implement custom authentication methods, without integrating these 
methods into the container's standard authentication methods.  Whether or not this is a  
good idea is a separate issue, but at the very least these applications lose association  
between a specific user account and the info in the access logs.  Therefore you can only understand  
how your users behave as an entire community, not as individuals or classes. You can make inferences from session ID and unique IP address, but you generally won't know which roles are attached to which requests.<br></p>
<p>Even in cases where you know which user caused a request, access logs do not directly tie requests to resource utilization 
and system behavior. Why did the request take so long to process?  Why is the response 
so large?  What parameters were provided with the request?  You may have separate logging 
of database activity or maybe even method calls, but you generally must correlate events using 
timestamps.  If you have a high volume application in which many events often happen within 
the same second, this is actually impossible to do with any reasonable accuracy.</p>

<h2>Logging Toolkits</h2>
<p>The use of toolkit logging 
(<a href="http://java.sun.com/j2se/1.4.2/docs/guide/util/logging/">Java Logging API</a>, 
<a href="http://commons.apache.org/logging/">Apache Commons Logging</a>, 
<a href="http://logging.apache.org/log4j/1.2/index.html">log4j</a>) is widely practiced 
in the global Java development community.  Logging statements allow you to select which 
information will be most useful for your own troubleshooting. 
Logging toolkits are highly configurable and allow you to dynamically increase 
the volume of information in areas where trouble is suspected.</p>
<p>One major limitation of toolkits is that high volume logging is expensive &mdash; it fills 
up your disk and takes processor time away from your application.  Learning when and what to log 
is an art that most programmers acquire naturally and will not be discussed here.  But even 
the most skillful programmer will frequently experience the logging hole:&nbsp; information 
seems to pour out of every part of the system except the one that is behaving badly. 
After all, if you knew it was going to be a problem, you wouldn't have written it that way, 
right?  The proactive, compile-time nature of logging is its essential weakness. Zealously adding a logging statement at every conditional branch, at every method open and close, and at every object 
instantiation and finalization is time-consuming, error-prone, erodes application 
performance, decreases code legibility, and generates log noise that distracts from 
the truly valuable information you are logging. A unique frustration of troubleshooting a flagging system is discovering that a critical stacktrace has been rotated out of existence by 
a debug message that is being logged every 3 seconds.  Of course you can then tune 
your configuration appropriately, but at that point you must wait for your error to happen again. Even so you can't add logging statements without a recompile / redeploy, which in tightly 
controlled environments may be difficult or entirely forbidden.</p>
<p>Assume that you have precisely predicted your logging needs, and have a calibrated 
configuration that tells you exactly what your system is doing.&nbsp; Still, like access logging, you must often do  
extra work to infer relationships between the toolkit logging and 
other streams of information (database logs, access logs, performance monitors).</p>

<h2>Profilers, Performance Logging</h2>
<p>The Java virtual machine now hosts a <a href="http://java.sun.com/docs/performance/">rich toolset</a> 
for logging performance data about an application &mdash; method calls, class construction and destruction, garbage
collector behavior.  Profiling tools like <a href="http://www.eclipse.org/tptp/">Eclipse TPTP</a> 
allow you to connect to a virtual machine and mine this data in exhaustive detail.</p>
<p>This is excellent in a test environment; but at time of this writing and for a long 
time before, a profiler is not a tool that can be easily used in production.  The 
impact on system responsiveness is massive, and interference from monitoring can 
obscure the source of the problem.  Profilers are generally a &quot;last mile&quot; tool &mdash; 
you've identified the problem scenario (which users, what they are doing, when), 
can reproduce the problem in a controlled environment, and want to know what the 
problem is at the level of bits and booleans.  Even less invasive tools like  
verbose GC and allocation logging must be used with care (usually reactively), 
and again require tedious correlation analysis with other data sources to arrive 
at meaningful results.</p>

<h1>Where BehaviorTracking Fits</h1>
<p>From the above discussion, there are some obvious needs not <i>easily</i> met by existing tools:</p>
<ol>
<li>Easy addition of instrumentation at runtime, not compile-time</li>
<li>Logging that is both detailed (method-call granularity) and low-overhead, so that it 
can <i>always</i> be active, even in production</li><li><b>most importantly</b>, strong correlation of events across multiple layers of  
a system, so that you know which request triggered that expensive SQL statement without needing to infer it.</li>
</ol>
<p>BehaviorTracking aims to balance these needs against each other, so that you can react with more  
focus to production problems, and so that you can proactively understand how users behave as you  
consider ways to grow your system.&nbsp; The ideal use of BehaviorTracking combines it with judicious toolkit logging, system resource monitoring, and JMX console access to provide you with a profoundly detailed portrait of your live production system.</p>

<h2>Why Spring?</h2>
<p>The first release of BehaviorTracking targets <a href="http://www.springframework.org">Spring</a> applications exclusively.  This is mostly because of Spring's 
excellent runtime AOP support, which is critical to BehaviorTracking's aim of zero code modification.
Spring is also unusual in being of generally high quality, completely free, and wildly popular.  Finally,
many other important frameworks make Spring compatibility a priority.</p>
<p>Still, the core components of BehaviorTracking are not tightly coupled to Spring and support for other
deployment scenarios is conceivable.  Deployment in a pure EJB3 container is a likely target for a 
future release.</p>

<h2>Commercial and Open-Source Alternatives</h2>
<p>There are many high-quality commercial alternatives.  If closed-source and/or commercial tools 
are an option for you, make sure you evaluate a few.  We won't specifically endorse any of them here, 
however :).  Generally the benefit of a commercial alternative will be in the out-of-the-box data 
analysis tools; with our library, you mostly get the data, and what you do with it is your business. 
Many portal application servers (Sun Glassfish and BEA WebLogic come to mind) have some behavior 
tracking features; make sure you consider the capabilities of your target platform.&nbsp; Even if you have some tools available, BehaviorTracking may offer you something in simplicity, flexibility, and performance.<br></p>
<p>There are also a few excellent open source projects out there geared toward gathering performance
metrics in a production system.  Among these, we believe BehaviorTracking to be fairly unique in its layered
approach to monitoring.</p>
</body>
</html>