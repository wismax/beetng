<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book>
	<title>Behavior Tracking 1.x User's Guide</title>
	<bookinfo>
		<author><firstname>Jason</firstname><surname>Trump</surname></author>
		<date>24 March 2009</date>
		<keywordset>
			<keyword>behavior tracking</keyword>
			<keyword>performance monitoring</keyword>
			<keyword>java programming</keyword>
			<keyword>behavior analytics</keyword>
			<keyword>spring framework</keyword>
		</keywordset>
	</bookinfo>
	<chapter id="chapter_getting_started">
		<title>Quick Start</title>
		<section>
			<title>Overview</title>
			<para>You are reading reference documentation for the MTGI BehaviorTracking library.  
			BehaviorTracking records application metrics as a user (or programmatic agent) interacts with
			a <ulink url="http://www.springframework.org">Spring-based</ulink> 
			application.</para>
			
			<para>No source-level modification is required in the instrumented application; measurement 
			is enabled completely at runtime. Metrics are tied to a specific user and session, and can be  
			collected for servlet requests, Java method calls, and/or SQL statements.  Metrics  
			can be stored in various file formats or directly in a relational database.  The API is  
			extensible to support other persistence mechanisms and metrics gathering at other   
			layers of an application.</para>
			
			<para><xref linkend="chapter_justification"/> contains a more detailed discussion of where 
			BehaviorTracking belongs in the broader picture of production monitoring.</para>
		</section>
		<section>
			<title>Simplified Installation</title> 
			<para>The BehaviorTracking.jar library and dependencies should be included in the target  
			application's library directory, e.g. <literal>WEB-INF/lib</literal> for web applications.  
			BehaviorTracking is then enabled separately for tracking HTTP requests, Java  
			method calls, and/or SQL queries. Behavior can be fine-tuned in many ways, but 
			the steps for a basic installation at all layers of an existing Spring application are:

			<orderedlist>
				<listitem><para>Add the library and its dependencies to the application.</para></listitem>
				<listitem>
					<para>Add behavior tracking markup to your Spring applicationContext.xml file
					(modify values to suit your application): 
					<example>
						<title>Adding method call tracking to applicationContext.xml</title>
						<programlisting><![CDATA[<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:bt="http://www.mantis-tgi.com/schema/bt/1.1"
       xsi:schemaLocation="
          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
          http://www.mantis-tgi.com/schema/bt         http://www.mantis-tgi.com/schema/bt/mtgi-bt-1.1.xsd
          http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop-2.0.xsd">

   <!-- 
        enable behavior tracking.  track-method-expression is an AOP 
        expression identifying which methods we want to profile in the behavior
        tracking logs; leave it out to skip Java method call metrics.
   -->
   <bt:config>
      <bt:manager application="myapp"]]><co id="appname"/><![CDATA[
                  track-method-expression="execution(* com.mtgi.analytics..*Tracked(..))"/>]]><co id="pattern"/><![CDATA[
   </bt:config>]]></programlisting>
						<calloutlist>
							<callout arearefs="appname"><para>The name of this application, as it will
							appear in behavior tracking logs.</para></callout>
							<callout arearefs="pattern"><para>An AspectJ pointcut expression identifying which
							methods you want to track in your application.  This example identifies "all methods
							in the com.mtgi.analytics package with names ending in "Tracked".  For a detailed 
							description of this grammar, see the 
							<ulink url="http://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">AspectJ programming guide</ulink>.</para>
							</callout>
						</calloutlist>
					</example>
					</para>
				</listitem>
				<listitem>
					<para><emphasis role="bold">(optional)</emphasis> To enable tracking for <emphasis role="bold">http requests</emphasis>, 
					add the behavior tracking servlet filter to web.xml: 
					<example>
						<title>Adding request tracking to web.xml</title>
						<programlisting><![CDATA[<!-- enable behavior tracking for servlet requests -->
<filter>
   <filter-name>trackingFilter</filter-name>
   <filter-class>com.mtgi.analytics.servlet.BehaviorTrackingFilter</filter-class>
   <init-param>
   <!-- request parameters are not logged by default.  to log specific 
        parameters, list them here -->
      <param-name>com.mtgi.analytics.parameters.include</param-name>
      <param-value>dispatch</param-value>
   </init-param>
</filter>
<filter-mapping>
   <filter-name>trackingFilter</filter-name>
   <servlet-name>action</servlet-name>
   <dispatcher>REQUEST</dispatcher>
</filter-mapping>]]></programlisting></example>
					</para>
				</listitem>
				<listitem><para><emphasis role="bold">(optional)</emphasis> To enable behavior tracking at the 
					<emphasis role="bold">SQL</emphasis> level, add a custom attribute to the data  
					source declaration in your spring configuration:  
					<example>
						<title>Adding SQL tracking to applicationContext.xml</title>
						<programlisting><![CDATA[<bean id="myDataSource" class="..." 
      ]]><emphasis role="bold"><![CDATA[bt:tracking-manager="defaultTrackingManager">]]></emphasis><co id="managerid"/><![CDATA[

   ... normal datasource configuration ... 

</bean>]]></programlisting>
						<calloutlist>
							<callout arearefs="managerid"><para>This name points back to
							an instance of the <literal>bt:manager</literal> element
							as described above, which is used to configure application-wide
							behavior tracking settings.  This name is the <literal>id</literal>
							attribute of your <literal>bt:manager</literal> element, or <literal>defaultTrackingManager</literal>
							if <literal>bt:manager</literal> does not have an id.</para></callout>
						</calloutlist>
					</example>
				</para></listitem>
			</orderedlist>
			</para>
		</section>

		<section>
			<title>Log Analysis</title>
			<para>The BehaviorTracking build generates a command-line tool suite for 
			analyzing BehaviorTracking logs. The tool suite can be used to convert binary 
			logs to CSV or XML, apply custom XSL transforms, and perform efficient bulk 
			loads of BehaviorTracking data to an Oracle database. The tools require the 
			following:
			<itemizedlist>
				<listitem><simpara>Solaris, Linux, or Cygwin environment</simpara></listitem>
				<listitem><simpara>Local Java 5 or Java 6 SDK installation</simpara></listitem>
				<listitem><simpara>If you plan to use the Oracle ETL scripts, an Oracle 9i or 
				higher client install</simpara></listitem>
			</itemizedlist>
			</para>

			<para>There are two packages, for java 5 and java 6; you only need to install the 
			version appropriate to your local SDK install.</para> 
			 
			<para>After you have unpacked the archive, you can run any of the following utilities 
			from a command prompt within the created <literal>BehaviorTracking</literal> directory.  All of these 
			instructions assume you are logging in the default format, GZIP-compressed FastInfoSet 
			(i.e. binary XML).</para>

			<section>
				<title>Upload to an Oracle Database</title>
				
				<orderedlist>
					<listitem><para><emphasis role="bold">(first time only)</emphasis> Run the provided etl/create_etl.sql script to create
					the required data structures in your target Oracle database.</para></listitem>
					<listitem>
						<para>Run the import script:
						<informalexample><screen>&gt; ./load-event.sh user/pass@sid path/to/log.bxml.gz</screen></informalexample>
						</para>
					</listitem>
					<listitem><para>The time required for this process will vary with available system resources, 
					the size of the log, the speed of your connection to the database, and so on.  Examine 
					the resulting log files <literal>load_event_csv.log</literal> and (if there were error records) 
					<literal>BAD_EVENT_CSV.log</literal>. Typically errors will only occur if you have tried to insert values to large for the target 
					schema.  If this is the case, you may want to update the schema to accommodate the larger values, 
					or truncate the bad data (in <literal>BAD_EVENT_CSV.log</literal>) and attempt the load again. The provided 
					structures are adequate to handle most needs, so errors should be rare.</para></listitem>
				</orderedlist>
				
				<caution>
					<title>Important Note for Cygwin Users:</title>
					<para>While the script supports Cygwin, an Oracle sqlldr limitation requires the use 
					of <emphasis>very large</emphasis> temporary files in a Cygwin environment.  It is strongly recommended that 
					you execute the upload scripts from a true Unix environment with stronger pipeline support, 
					such as Solaris or Linux.</para>
				</caution>
				
				<para>Use of the provided script is simple, but database administration is up to you. 
				Depending on what you hope to do with your data, you will likely want to customize 
				the ETL process to suit your needs. Therefore familiarity with sqlldr and basic 
				Oracle database administration is assumed here. You should examine the provided 
				scripts and make sure you understand what they do before using them.</para>
			</section>
			
			<section>
				<title>Export to XML</title>
				<para>
					You can easily export a binary log to a simple XML format legible to humans or other XML
					processing utilities:
					<informalexample><screen>&gt; zcat path/to/log.bxml.gz | java -jar bt-utils.jar -tool xml &gt; result.xml</screen></informalexample>
				</para>
				<para>Be careful, though; the default compressed-binary format has a compression ratio
				of around 20:1 compared to its plain-text counterpart, so you can use a lot of disk this way.
				If you plan to apply an XSL transform to the output document, consider the XSLT mode of the
				export tool asoutlined below.</para>
			</section>
			
			<section>
				<title>Export to CSV</title>
				<para>
					Similarly, you can export to a CSV file for use in a spreadsheet or older EDI tools:
					<informalexample><screen>&gt; zcat path/to/log.bxml.gz | java -jar bt-utils.jar -tool csv &gt; result.csv</screen></informalexample>
				</para>
				<para>Again, assume that your CSV data will be quite a bit larger than the compressed-binary data.</para>
			</section>
			
			<section>
				<title>Export with custom XSL</title>
				<para>You can certainly use the XML export and stream the result to an XSL transformer.
				However, executing XSL transforms on large XML documents can be extremely resource-intensive
				without specialized tools.  Included with the log analysis package is an analyzer
				that splits a large input document into fragments based on an XPath query, and then
				applies an XSL transform to each fragment.  For transforms that are stateless or only need
				to examine a small part of a document, this is vastly more efficient than loading an entire document to invoke the transform.</para>
				
				<para>The following example splits the input document into one fragment per 'event' element,
				applying the given XSL transform file to each fragment and streaming the result to standard
				out:
					<informalexample><screen>&gt; zcat path/to/log.bxml.gz | java -jar bt-utils.jar -tool xslt -split event-log/event -xsl etl/insert_events.xsl &gt; result.csv</screen></informalexample>
				</para>
				 
				<para>The included file <varname>etl/insert_events.xsl</varname> provides an example transform document, including some custom XSL functions available to transforms 
				invoked in this way.</para>
			</section>
		</section>
		
	</chapter>
	
	<chapter id="chapter_justification">
		<title>Justification</title>
		<para>It is hard to predict how users will engage your application before it hits production.  You can invest much or little in your attempts to 
		predict demand, but in either case your best educated guess cannot dictate  
		the future.  If you can avoid performance problems on first release, monitoring  
		is paramount to ensure that things stay under control  as users find new ways to  
		torture your application.  If you do have problems on initial deployment,  
		monitoring is paramount to finding and addressing a problem quickly. In any case,  
		production monitoring is required.</para>
		
		<section>
			<title>Existing Tools and Methods</title> 
			<para>There are many powerful tools available to monitor any modern Java application.  BehaviorTracking 
			is designed to augment, not replace, the information that these tools provide.  A successful 
			system will have a place for <emphasis>every one of these tools</emphasis>, almost without exception. What's most important is that you 
			<emphasis>actually measure</emphasis> your system to understand where the problems lie.  The temptation 
			to arbitrarily pick your least favorite part of the application and rewrite while your users suffer is a 
			strong one and a good way to lose credibility.  The same goes for measuring arbitrary behaviors in a controlled test environment without a clear analogy to production user behavior. If your suspicion feels like certainty, it 
			should be easy to find hard evidence to back it up, but don't forgo the exercise.</para>
			
			<section>
				<title>System Resource Monitoring</title>
				<para>System resource monitoring tools are widely available and do not require you 
				to make any special considerations in your application.  For example, most modern 
				Windows systems have <ulink url="http://technet.microsoft.com/en-us/library/cc749115.aspx">Performance Monitor</ulink>, 
				and most Unix systems will include some 
				variant of <ulink url="http://pagesperso-orange.fr/sebastien.godard/documentation.html">sar</ulink>. In either case, 
				you should be able to identify bottlenecks at the 
				resource level (disk, memory, CPU, network).  If your system is simply being asked 
				to do too much with the tools given, and you can address bottlenecks with better hardware, that's excellent.</para>
				<para>If you are having application responsiveness problems and your resources are  
				underutilized, you can't hope to get much more out of your resource monitors and must 
				dig deeper.  If your system is overutilized with two users logging in and nothing more, you must dig 
				deeper.  In short, you should anticipate a need for deeper visibility into your application 
				than what resource monitoring tools alone can provide.</para>
			</section>
			
			<section>
				<title>JMX Monitoring</title>
				<para>Modern Java application servers provide a wealth of information to JMX clients 
				(<ulink url="http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html">jconsole</ulink>, 
				<ulink url="http://mc4j.org">MC4J</ulink>). 
				If your application is overpowering the CPU, you can quickly identify which threads 
				are eating your processor and what code they are executing while they are doing it. 
				You can view heap memory use statistics, identify deadlocked threads, and usually  
				(depending on application server) exercise some control over user sessions.</para>
				<para>A significant limitation of JMX monitoring tools is that it is difficult to perform 
				post-mortem analysis after your system has become unresponsive.  If your application 
				is leaking memory, or pegs your processor, users of JMX clients are frequently 
				as out-of-luck as users of your application. Some IT departments will consider (not entirely without merit) JMX  
				access a security risk and will refuse to activate it.</para>
			</section>

			<section>
				<title>Access Logging</title>
				<para>All major web servers will provide some kind of configurable 
				<ulink url="http://httpd.apache.org/docs/2.0/logs.html#accesslog">access logging</ulink>, 
				usually in the style of the <ulink url="http://httpd.apache.org/">Apache web server</ulink>.
				An access log may include which URL was requested, 
				when the request was made, which user made the request, a session ID associated with the request,  
				how long the server spent processing the request, how large the response was, 
				and whether the processing resulted in any errors.  The access log is the primary data 
				source for many user analytics packages.  If you are writing a web application, access 
				logging is a powerful tool for understanding how users are accessing your application 
				and how their behavior changes over time.</para>
				<para>Many applications implement custom authentication methods, without integrating these 
				methods into the container's standard authentication methods.  Whether or not this is a  
				good idea is a separate issue, but at the very least these applications lose association  
				between a specific user account and the info in the access logs.  Therefore you can only understand  
				how your users behave as an entire community, not as individuals or classes. You can make inferences 
				from session ID and unique IP address, but you generally won't know which roles
				are attached to which requests.</para>
				<para>Even in cases where you know which user caused a request, access logs do not directly tie requests to resource utilization 
				and system behavior. Why did the request take so long to process?  Why is the response 
				so large?  What parameters were provided with the request?  You may have separate logging 
				of database activity or maybe even method calls, but you generally must correlate events using 
				timestamps.  If you have a high volume application in which many events often happen within 
				the same second, this is actually impossible to do with any reasonable accuracy.</para>
			</section>
			
			<section>
				<title>Logging Toolkits</title>
				<para>The use of toolkit logging 
				(<ulink url="http://java.sun.com/j2se/1.4.2/docs/guide/util/logging/">Java Logging API</ulink>, 
				<ulink url="http://commons.apache.org/logging/">Apache Commons Logging</ulink>, 
				<ulink url="http://logging.apache.org/log4j/1.2/index.html">log4j</ulink>) is widely practiced 
				in the global Java development community.  Logging statements allow you to select which 
				information will be most useful for your own troubleshooting. 
				Logging toolkits are highly configurable and allow you to dynamically increase 
				the volume of information in areas where trouble is suspected.</para>
				<para>One major limitation of toolkits is that high volume logging is expensive -- it fills 
				up your disk and takes processor time away from your application.  Learning when and what to log 
				is an art that most programmers acquire naturally and will not be discussed here.  But even 
				the most skillful programmer will frequently experience the logging hole: information 
				seems to pour out of every part of the system except the one that is behaving badly. 
				After all, if you knew it was going to be a problem, you wouldn't have written it that way, 
				right?  The proactive, compile-time nature of logging is its essential weakness. Zealously adding a logging 
				statement at every conditional branch, at every method open and close, and at every object 
				instantiation and finalization is time-consuming, error-prone, erodes application 
				performance, decreases code legibility, and generates log noise that distracts from 
				the truly valuable information you are logging. A unique frustration of troubleshooting a flagging system 
				is discovering that a critical stacktrace has been rotated out of existence by 
				a debug message that is being logged every 3 seconds.  Of course you can then tune 
				your configuration appropriately, but at that point you must wait for your error to happen again. Even so you 
				can't add logging statements without a recompile / redeploy, which in tightly 
				controlled environments may be difficult or entirely forbidden.</para>
				<para>Assume that you have precisely predicted your logging needs, and have a calibrated 
				configuration that tells you exactly what your system is doing. Still, like access logging, you must often do  
				extra work to infer relationships between the toolkit logging and 
				other streams of information (database logs, access logs, performance monitors).</para>
			</section>
			
			<section>
				<title>Profilers, Performance Logging</title>
				<para>The Java virtual machine now hosts a <ulink url="http://java.sun.com/docs/performance/">rich toolset</ulink> 
				for logging performance data about an application -- method calls, class construction and destruction, garbage
				collector behavior.  Profiling tools like <ulink url="http://www.eclipse.org/tptp/">Eclipse TPTP</ulink> 
				allow you to connect to a virtual machine and mine this data in exhaustive detail.</para>
				<para>This is excellent in a test environment; but at time of this writing and for a long 
				time before, a profiler is not a tool that can be easily used in production.  The 
				impact on system responsiveness is massive, and interference from monitoring can 
				obscure the source of the problem.  Profilers are generally a &quot;last mile&quot; tool -- 
				you've identified the problem scenario (which users, what they are doing, when), 
				can reproduce the problem in a controlled environment, and want to know what the 
				problem is at the level of bits and booleans.  Even less invasive tools like  
				verbose GC and allocation logging must be used with care (usually reactively), 
				and again require tedious correlation analysis with other data sources to arrive 
				at meaningful results.</para>
			</section>
		</section>
		
		<section>
			<title>Where BehaviorTracking Fits</title>
			<para>From the above discussion, there are some obvious needs not <emphasis>easily</emphasis> met by existing tools:
			<orderedlist>
			<listitem><para>Easy addition of instrumentation at runtime, not compile-time</para></listitem>
			<listitem><para>Logging that is both detailed (method-call granularity) and low-overhead, so that it 
			can <emphasis>always</emphasis> be active, even in production</para></listitem>
			<listitem><para><emphasis role="bold">most importantly</emphasis>, strong correlation of events across multiple layers of  
			a system, so that you know which request triggered that expensive SQL statement without needing to infer it.</para></listitem>
			</orderedlist>
			</para>
			<para>BehaviorTracking aims to balance these needs against each other, so that you can react with more  
			focus to production problems, and so that you can proactively understand how users behave as you  
			consider ways to grow your system. The ideal use of BehaviorTracking combines it with judicious toolkit 
			logging, system resource monitoring, and JMX console access to provide you with a profoundly detailed portrait 
			of your live production system.</para>
			
			<section>
				<title>Why Spring?</title>
				<para>The first release of BehaviorTracking targets <ulink url="http://www.springframework.org">Spring</ulink> 
				applications exclusively.  This is mostly because of Spring's 
				excellent runtime AOP support, which is critical to BehaviorTracking's aim of zero code modification.
				Spring is also unusual in being of generally high quality, completely free, and wildly popular.  Finally,
				many other important frameworks make Spring compatibility a priority.</para>
				<para>Still, the core components of BehaviorTracking are not tightly coupled to Spring and support for other
				deployment scenarios is conceivable.  Deployment in a pure EJB3 container is a likely target for a 
				future release.</para>
			</section>
			
			<section>
				<title>Commercial and Open-Source Alternatives</title>
				<para>There are many high-quality commercial alternatives.  If closed-source and/or commercial tools 
				are an option for you, make sure you evaluate a few.  We won't specifically endorse any of them here, 
				however :).  Generally the benefit of a commercial alternative will be in the out-of-the-box data 
				analysis tools; with our library, you mostly get the data, and what you do with it is your business. 
				Many portal application servers (Sun Glassfish and BEA WebLogic come to mind) have some behavior 
				tracking features; make sure you consider the capabilities of your target platform. Even if you have 
				some tools available, BehaviorTracking may offer you something in simplicity, flexibility, and performance.</para>
				<para>There are also a few excellent open source projects out there geared toward gathering performance
				metrics in a production system.  Among these, we believe BehaviorTracking to be fairly unique in its layered
				approach to monitoring.</para>
			</section>
		</section>
	</chapter>
	
	<chapter>
		<title>Programmer Reference</title>
		<para>You only need to refer to the API documentation if you plan to write new persisters, application-specific modules, or log analysis utilities. 
		For most applications the provided tools should be adequate.</para>
		<table>
			<title>API Modules</title>
			<tgroup cols="2">
				<tbody>
					<row>
						<entry><ulink url="../../api/index.html">Core</ulink></entry>
						<entry>BehaviorTracking core interfaces and utility classes.  
						This library is packaged as <literal>BehaviorTracking-[version].jar</literal>.
						This package contains interfaces you must implement for custom persistence 
						mechanisms and user identity providers.</entry>
					</row>
					<row>
						<entry><ulink url="../../../utils/docs/api/index.html">Log Analysis Utilities</ulink></entry>
						<entry>is a library useful for manipulating common behavior tracking log formats.  These
						tools are primarily intended for command line use, but can be programmatically extended
						to support custom data loaders.</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
	</chapter>
</book>